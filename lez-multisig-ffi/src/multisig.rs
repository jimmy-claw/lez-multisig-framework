//! Auto-generated C FFI for the multisig_program program.
//! Generated by lez-client-gen. DO NOT EDIT.
//!
//! Required JSON fields for every instruction call:
//!   - `wallet_path`: path to NSSA wallet directory
//!   - `sequencer_url`: e.g. "http://127.0.0.1:3040"
//!   - `program_id_hex`: 64-char hex string identifying the program

use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use serde_json::{Value, json};
use sha2::{Sha256, Digest};
use nssa::{AccountId, ProgramId, PublicTransaction};
use nssa::public_transaction::{Message, WitnessSet};
use wallet::WalletCore;
use multisig_core::Instruction as ProgramInstruction;

fn cstr_to_str<'a>(ptr: *const c_char) -> Result<&'a str, String> {
    if ptr.is_null() { return Err("null pointer".into()); }
    unsafe { CStr::from_ptr(ptr) }.to_str().map_err(|e| format!("invalid UTF-8: {}", e))
}

fn to_cstring(s: String) -> *mut c_char {
    CString::new(s).unwrap_or_else(|_|
        CString::new(r#"{"success":false,"error":"null byte"}"#).unwrap()
    ).into_raw()
}

fn error_json(msg: &str) -> *mut c_char {
    let v = serde_json::json!(msg).to_string();
    let body = format!("{{\"success\":false,\"error\":{}}}", v);
    to_cstring(body)
}

fn compute_pda(seeds: &[&[u8]]) -> AccountId {
    let mut hasher = Sha256::new();
    for seed in seeds {
        let mut padded = [0u8; 32];
        let len = seed.len().min(32);
        padded[..len].copy_from_slice(&seed[..len]);
        hasher.update(&padded);
    }
    let hash: [u8; 32] = hasher.finalize().into();
    AccountId::new(hash)
}

fn parse_program_id_hex(s: &str) -> Result<ProgramId, String> {
    let s = s.trim_start_matches("0x");
    if s.len() != 64 { return Err(format!("program_id hex must be 64 chars, got {}", s.len())); }
    let bytes = hex::decode(s).map_err(|e| format!("invalid hex: {}", e))?;
    let mut pid = [0u32; 8];
    for (i, chunk) in bytes.chunks(4).enumerate() {
        pid[i] = u32::from_le_bytes(chunk.try_into().unwrap());
    }
    Ok(pid)
}

fn parse_program_id(s: &str) -> Result<ProgramId, String> {
    parse_program_id_hex(s)
}

fn hex_to_bytes_32(s: &str) -> Result<[u8; 32], String> {
    let bytes = hex::decode(s).map_err(|e| format!("invalid hex: {}", e))?;
    if bytes.len() != 32 {
        return Err(format!("expected 32 bytes, got {}", bytes.len()));
    }
    let mut arr = [0u8; 32];
    arr.copy_from_slice(&bytes);
    Ok(arr)
}



fn parse_account_id(s: &str) -> Result<AccountId, String> {
    if let Ok(id) = s.parse() { return Ok(id); }
    let s = s.trim_start_matches("0x");
    if s.len() == 64 {
        let bytes = hex::decode(s).map_err(|e| format!("invalid hex: {}", e))?;
        let mut arr = [0u8; 32]; arr.copy_from_slice(&bytes);
        return Ok(AccountId::new(arr));
    }
    Err(format!("invalid AccountId: {}", s))
}

fn init_wallet(v: &Value) -> Result<WalletCore, String> {
    if let Some(p) = v["wallet_path"].as_str() {
        std::env::set_var("NSSA_WALLET_HOME_DIR", p);
    }
    WalletCore::from_env().map_err(|e| format!("wallet init: {}", e))
}

/// FFI: create_multisig instruction.
#[no_mangle]
pub extern "C" fn multisig_program_create_multisig(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_create_multisig_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_create_multisig_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().or_else(|| v["multisig_program_id"].as_str()).ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let create_key = hex_to_bytes_32(v["create_key"].as_str().ok_or("missing create_key")?)?;
    let threshold = v["threshold"].as_u64().ok_or("expected number")? as u8;
    let members: Vec<AccountId> = v["members"].as_array().ok_or("expected array")?.iter().map(|item| parse_account_id(item.as_str().ok_or("member must be string")?)).collect::<Result<Vec<_>, String>>()?;

    let multisig_state = compute_pda(&[
        &create_key as &[u8],
    ]);

    let signer = parse_account_id(v["account"].as_str().ok_or("missing account")?)?;
    let mut account_ids: Vec<AccountId> = vec![multisig_state];
    account_ids.extend(members.iter().cloned());
    account_ids.push(signer);
    let signer_ids: Vec<AccountId> = vec![signer];

    let instruction = ProgramInstruction::CreateMultisig {
        create_key,
        threshold,
        members,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

/// FFI: propose instruction.
#[no_mangle]
pub extern "C" fn multisig_program_propose(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_propose_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_propose_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().or_else(|| v["multisig_program_id"].as_str()).ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let target_program_id = parse_program_id(v["target_program_id"].as_str().ok_or("expected string for ProgramId")?)?;
    let target_instruction_data = v["target_instruction_data"].as_array().ok_or("expected array")?.iter().map(|item| Ok(item.as_u64().ok_or("expected number")? as u32)).collect::<Result<Vec<_>, String>>()?;
    let target_account_count = v["target_account_count"].as_u64().ok_or("expected number")? as u8;
    let pda_seeds = v["pda_seeds"].as_array().ok_or("expected array")?.iter().map(|item| Ok(serde_json::from_value(item.clone()).map_err(|e| format!("parse error: {}", e))?)).collect::<Result<Vec<_>, String>>()?;
    let authorized_indices = v["authorized_indices"].as_array().ok_or("expected array")?.iter().map(|item| Ok(item.as_u64().ok_or("expected number")? as u8)).collect::<Result<Vec<_>, String>>()?;

    let multisig_state = parse_account_id(v["multisig_state"].as_str().ok_or("missing multisig_state")?)?;
    let proposer = parse_account_id(v["proposer"].as_str().ok_or("missing proposer")?)?;
    let proposal = parse_account_id(v["proposal"].as_str().ok_or("missing proposal")?)?;

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
        proposer,
        proposal,
    ];
    let signer_ids: Vec<AccountId> = vec![
        proposer,
    ];

    let instruction = ProgramInstruction::Propose {
        target_program_id,
        target_instruction_data,
        target_account_count,
        pda_seeds,
        authorized_indices,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

/// FFI: approve instruction.
#[no_mangle]
pub extern "C" fn multisig_program_approve(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_approve_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_approve_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().or_else(|| v["multisig_program_id"].as_str()).ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let proposal_index = v["proposal_index"].as_u64().ok_or("expected number")? as u64;

    let multisig_state = parse_account_id(v["multisig_state"].as_str().ok_or("missing multisig_state")?)?;
    let approver = parse_account_id(v["approver"].as_str().ok_or("missing approver")?)?;
    let proposal = parse_account_id(v["proposal"].as_str().ok_or("missing proposal")?)?;

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
        approver,
        proposal,
    ];
    let signer_ids: Vec<AccountId> = vec![
        approver,
    ];

    let instruction = ProgramInstruction::Approve {
        proposal_index,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

/// FFI: reject instruction.
#[no_mangle]
pub extern "C" fn multisig_program_reject(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_reject_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_reject_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().or_else(|| v["multisig_program_id"].as_str()).ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let proposal_index = v["proposal_index"].as_u64().ok_or("expected number")? as u64;

    let multisig_state = parse_account_id(v["multisig_state"].as_str().ok_or("missing multisig_state")?)?;
    let rejector = parse_account_id(v["rejector"].as_str().ok_or("missing rejector")?)?;
    let proposal = parse_account_id(v["proposal"].as_str().ok_or("missing proposal")?)?;

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
        rejector,
        proposal,
    ];
    let signer_ids: Vec<AccountId> = vec![
        rejector,
    ];

    let instruction = ProgramInstruction::Reject {
        proposal_index,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

/// FFI: execute instruction.
#[no_mangle]
pub extern "C" fn multisig_program_execute(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_execute_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_execute_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().or_else(|| v["multisig_program_id"].as_str()).ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let proposal_index = v["proposal_index"].as_u64().ok_or("expected number")? as u64;

    let multisig_state = parse_account_id(v["multisig_state"].as_str().ok_or("missing multisig_state")?)?;
    let executor = parse_account_id(v["executor"].as_str().ok_or("missing executor")?)?;
    let proposal = parse_account_id(v["proposal"].as_str().ok_or("missing proposal")?)?;
    let target_accounts = parse_account_id(v["target_accounts"].as_str().ok_or("missing target_accounts")?)?;

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
        executor,
        proposal,
        target_accounts,
    ];
    let signer_ids: Vec<AccountId> = vec![
        executor,
    ];

    let instruction = ProgramInstruction::Execute {
        proposal_index,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

#[no_mangle]
pub extern "C" fn multisig_program_free_string(s: *mut c_char) {
    if !s.is_null() { unsafe { drop(CString::from_raw(s)) }; }
}

#[no_mangle]
pub extern "C" fn multisig_program_version() -> *mut c_char {
    to_cstring("0.1.0".to_string())
}

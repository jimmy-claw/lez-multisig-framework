// GENERATED FILE â€” do not edit manually. Run make generate to regenerate.
//! Auto-generated C FFI for the multisig_program program.
//! Generated by lez-client-gen. DO NOT EDIT.
//!
//! Required JSON fields for every instruction call:
//!   - `wallet_path`: path to NSSA wallet directory
//!   - `sequencer_url`: e.g. "http://127.0.0.1:3040"
//!   - `program_id_hex`: 64-char hex string identifying the program

use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use serde_json::{Value, json};
use sha2::{Sha256, Digest};
use nssa::{AccountId, ProgramId, PublicTransaction};
use nssa::public_transaction::{Message, WitnessSet};
use wallet::WalletCore;
use multisig_core::Instruction as ProgramInstruction;

fn cstr_to_str<'a>(ptr: *const c_char) -> Result<&'a str, String> {
    if ptr.is_null() { return Err("null pointer".into()); }
    unsafe { CStr::from_ptr(ptr) }.to_str().map_err(|e| format!("invalid UTF-8: {}", e))
}

fn to_cstring(s: String) -> *mut c_char {
    CString::new(s).unwrap_or_else(|_|
        CString::new(r#"{"success":false,"error":"null byte"}"#).unwrap()
    ).into_raw()
}

fn error_json(msg: &str) -> *mut c_char {
    let v = serde_json::json!(msg).to_string();
    let body = format!("{{\"success\":false,\"error\":{}}}", v);
    to_cstring(body)
}

fn compute_pda(seeds: &[&[u8]]) -> AccountId {
    let mut hasher = Sha256::new();
    for seed in seeds {
        let mut padded = [0u8; 32];
        let len = seed.len().min(32);
        padded[..len].copy_from_slice(&seed[..len]);
        hasher.update(&padded);
    }
    let hash: [u8; 32] = hasher.finalize().into();
    AccountId::new(hash)
}

fn parse_program_id_hex(s: &str) -> Result<ProgramId, String> {
    let s = s.trim_start_matches("0x");
    if s.len() != 64 { return Err(format!("program_id hex must be 64 chars, got {}", s.len())); }
    let bytes = hex::decode(s).map_err(|e| format!("invalid hex: {}", e))?;
    let mut pid = [0u32; 8];
    for (i, chunk) in bytes.chunks(4).enumerate() {
        pid[i] = u32::from_le_bytes(chunk.try_into().unwrap());
    }
    Ok(pid)
}

fn parse_program_id(s: &str) -> Result<ProgramId, String> {
    parse_program_id_hex(s)
}

fn parse_account_id(s: &str) -> Result<AccountId, String> {
    if let Ok(id) = s.parse() { return Ok(id); }
    let s = s.trim_start_matches("0x");
    if s.len() == 64 {
        let bytes = hex::decode(s).map_err(|e| format!("invalid hex: {}", e))?;
        let mut arr = [0u8; 32]; arr.copy_from_slice(&bytes);
        return Ok(AccountId::new(arr));
    }
    Err(format!("invalid AccountId: {}", s))
}

fn init_wallet(v: &Value) -> Result<WalletCore, String> {
    if let Some(p) = v["wallet_path"].as_str() {
        std::env::set_var("NSSA_WALLET_HOME_DIR", p);
    }
    WalletCore::from_env().map_err(|e| format!("wallet init: {}", e))
}

/// FFI: create_multisig instruction.
#[no_mangle]
pub extern "C" fn multisig_program_create_multisig(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_create_multisig_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_create_multisig_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let create_key = serde_json::from_value(v["create_key"].clone()).map_err(|e| format!("parse error: {}", e))?;
    let threshold = v["threshold"].as_u64().ok_or("expected number")? as u8;
    let members = v["members"].as_array().ok_or("expected array")?.iter().map(|item| Ok(serde_json::from_value(item.clone()).map_err(|e| format!("parse error: {}", e))?)).collect::<Result<Vec<_>, String>>()?;

    let multisig_state = compute_pda(&[
        &create_key as &[u8],
    ]);
    let member_accounts: Vec<AccountId> = v["member_accounts"].as_array()
        .ok_or("missing member_accounts")?
        .iter().map(|a| parse_account_id(a.as_str().ok_or("expected string")?)).collect::<Result<Vec<_>,_>>()?;

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
    ];
    account_ids.extend(member_accounts);
    let signer_ids: Vec<AccountId> = vec![
    ];

    let instruction = ProgramInstruction::CreateMultisig {
        create_key,
        threshold,
        members,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

/// FFI: propose instruction.
#[no_mangle]
pub extern "C" fn multisig_program_propose(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_propose_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_propose_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let target_program_id = serde_json::from_value(v["target_program_id"].clone()).map_err(|e| format!("parse error: {}", e))?;
    let target_instruction_data = serde_json::from_value(v["target_instruction_data"].clone()).map_err(|e| format!("parse error: {}", e))?;
    let target_account_count = v["target_account_count"].as_u64().ok_or("expected number")? as u8;
    let pda_seeds = v["pda_seeds"].as_array().ok_or("expected array")?.iter().map(|item| Ok(serde_json::from_value(item.clone()).map_err(|e| format!("parse error: {}", e))?)).collect::<Result<Vec<_>, String>>()?;
    let authorized_indices = v["authorized_indices"].as_array().ok_or("expected array")?.iter().map(|item| Ok(item.as_u64().ok_or("expected number")? as u8)).collect::<Result<Vec<_>, String>>()?;
    let create_key = serde_json::from_value(v["create_key"].clone()).map_err(|e| format!("parse error: {}", e))?;
    let proposal_index = v["proposal_index"].as_u64().ok_or("expected number")? as u64;

    let multisig_state = parse_account_id(v["multisig_state"].as_str().ok_or("missing multisig_state")?)?;
    let proposer = parse_account_id(v["proposer"].as_str().ok_or("missing proposer")?)?;
    let proposal = compute_pda(&[
        b"multisig_prop___",
        &create_key as &[u8],
        &proposal_index.to_le_bytes(),
    ]);

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
        proposer,
        proposal,
    ];
    let signer_ids: Vec<AccountId> = vec![
        proposer,
    ];

    let instruction = ProgramInstruction::Propose {
        target_program_id,
        target_instruction_data,
        target_account_count,
        pda_seeds,
        authorized_indices,
        create_key,
        proposal_index,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

/// FFI: approve instruction.
#[no_mangle]
pub extern "C" fn multisig_program_approve(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_approve_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_approve_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let proposal_index = v["proposal_index"].as_u64().ok_or("expected number")? as u64;
    let create_key = serde_json::from_value(v["create_key"].clone()).map_err(|e| format!("parse error: {}", e))?;

    let multisig_state = parse_account_id(v["multisig_state"].as_str().ok_or("missing multisig_state")?)?;
    let approver = parse_account_id(v["approver"].as_str().ok_or("missing approver")?)?;
    let proposal = compute_pda(&[
        b"multisig_prop___",
        &create_key as &[u8],
        &proposal_index.to_le_bytes(),
    ]);

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
        approver,
        proposal,
    ];
    let signer_ids: Vec<AccountId> = vec![
        approver,
    ];

    let instruction = ProgramInstruction::Approve {
        proposal_index,
        create_key,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

/// FFI: reject instruction.
#[no_mangle]
pub extern "C" fn multisig_program_reject(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_reject_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_reject_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let proposal_index = v["proposal_index"].as_u64().ok_or("expected number")? as u64;
    let create_key = serde_json::from_value(v["create_key"].clone()).map_err(|e| format!("parse error: {}", e))?;

    let multisig_state = parse_account_id(v["multisig_state"].as_str().ok_or("missing multisig_state")?)?;
    let rejector = parse_account_id(v["rejector"].as_str().ok_or("missing rejector")?)?;
    let proposal = compute_pda(&[
        b"multisig_prop___",
        &create_key as &[u8],
        &proposal_index.to_le_bytes(),
    ]);

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
        rejector,
        proposal,
    ];
    let signer_ids: Vec<AccountId> = vec![
        rejector,
    ];

    let instruction = ProgramInstruction::Reject {
        proposal_index,
        create_key,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

/// FFI: execute instruction.
#[no_mangle]
pub extern "C" fn multisig_program_execute(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_execute_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_execute_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let proposal_index = v["proposal_index"].as_u64().ok_or("expected number")? as u64;
    let create_key = serde_json::from_value(v["create_key"].clone()).map_err(|e| format!("parse error: {}", e))?;

    let multisig_state = parse_account_id(v["multisig_state"].as_str().ok_or("missing multisig_state")?)?;
    let executor = parse_account_id(v["executor"].as_str().ok_or("missing executor")?)?;
    let proposal = compute_pda(&[
        b"multisig_prop___",
        &create_key as &[u8],
        &proposal_index.to_le_bytes(),
    ]);
    let target_accounts: Vec<AccountId> = v["target_accounts"].as_array()
        .ok_or("missing target_accounts")?
        .iter().map(|a| parse_account_id(a.as_str().ok_or("expected string")?)).collect::<Result<Vec<_>,_>>()?;

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
        executor,
        proposal,
    ];
    account_ids.extend(target_accounts);
    let signer_ids: Vec<AccountId> = vec![
        executor,
    ];

    let instruction = ProgramInstruction::Execute {
        proposal_index,
        create_key,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

/// FFI: propose_add_member instruction.
#[no_mangle]
pub extern "C" fn multisig_program_propose_add_member(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_propose_add_member_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_propose_add_member_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let new_member = serde_json::from_value(v["new_member"].clone()).map_err(|e| format!("parse error: {}", e))?;
    let create_key = serde_json::from_value(v["create_key"].clone()).map_err(|e| format!("parse error: {}", e))?;
    let proposal_index = v["proposal_index"].as_u64().ok_or("expected number")? as u64;

    let multisig_state = parse_account_id(v["multisig_state"].as_str().ok_or("missing multisig_state")?)?;
    let proposer = parse_account_id(v["proposer"].as_str().ok_or("missing proposer")?)?;
    let proposal = compute_pda(&[
        b"multisig_prop___",
        &create_key as &[u8],
        &proposal_index.to_le_bytes(),
    ]);

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
        proposer,
        proposal,
    ];
    let signer_ids: Vec<AccountId> = vec![
        proposer,
    ];

    let instruction = ProgramInstruction::ProposeAddMember {
        new_member,
        create_key,
        proposal_index,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

/// FFI: propose_remove_member instruction.
#[no_mangle]
pub extern "C" fn multisig_program_propose_remove_member(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_propose_remove_member_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_propose_remove_member_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let member = serde_json::from_value(v["member"].clone()).map_err(|e| format!("parse error: {}", e))?;
    let create_key = serde_json::from_value(v["create_key"].clone()).map_err(|e| format!("parse error: {}", e))?;
    let proposal_index = v["proposal_index"].as_u64().ok_or("expected number")? as u64;

    let multisig_state = parse_account_id(v["multisig_state"].as_str().ok_or("missing multisig_state")?)?;
    let proposer = parse_account_id(v["proposer"].as_str().ok_or("missing proposer")?)?;
    let proposal = compute_pda(&[
        b"multisig_prop___",
        &create_key as &[u8],
        &proposal_index.to_le_bytes(),
    ]);

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
        proposer,
        proposal,
    ];
    let signer_ids: Vec<AccountId> = vec![
        proposer,
    ];

    let instruction = ProgramInstruction::ProposeRemoveMember {
        member,
        create_key,
        proposal_index,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

/// FFI: propose_change_threshold instruction.
#[no_mangle]
pub extern "C" fn multisig_program_propose_change_threshold(args_json: *const c_char) -> *mut c_char {
    let args = match cstr_to_str(args_json) {
        Ok(s) => s, Err(e) => return error_json(&e),
    };
    match multisig_program_propose_change_threshold_impl(args) {
        Ok(r) => to_cstring(r), Err(e) => error_json(&e),
    }
}

fn multisig_program_propose_change_threshold_impl(args: &str) -> Result<String, String> {
    let v: Value = serde_json::from_str(args).map_err(|e| format!("invalid JSON: {}", e))?;
    let program_id = parse_program_id_hex(v["program_id_hex"].as_str().ok_or("missing program_id_hex")?)?;
    let wallet = init_wallet(&v)?;

    let new_threshold = v["new_threshold"].as_u64().ok_or("expected number")? as u8;
    let create_key = serde_json::from_value(v["create_key"].clone()).map_err(|e| format!("parse error: {}", e))?;
    let proposal_index = v["proposal_index"].as_u64().ok_or("expected number")? as u64;

    let multisig_state = parse_account_id(v["multisig_state"].as_str().ok_or("missing multisig_state")?)?;
    let proposer = parse_account_id(v["proposer"].as_str().ok_or("missing proposer")?)?;
    let proposal = compute_pda(&[
        b"multisig_prop___",
        &create_key as &[u8],
        &proposal_index.to_le_bytes(),
    ]);

    let mut account_ids: Vec<AccountId> = vec![
        multisig_state,
        proposer,
        proposal,
    ];
    let signer_ids: Vec<AccountId> = vec![
        proposer,
    ];

    let instruction = ProgramInstruction::ProposeChangeThreshold {
        new_threshold,
        create_key,
        proposal_index,
    };

    let rt = tokio::runtime::Runtime::new().map_err(|e| format!("tokio: {}", e))?;
    let tx_hash = rt.block_on(async {
        let nonces = wallet.get_accounts_nonces(signer_ids.clone()).await
            .map_err(|e| format!("nonces: {}", e))?;
        let mut signing_keys = Vec::new();
        for sid in &signer_ids {
            let key = wallet.storage().user_data
                .get_pub_account_signing_key(*sid)
                .ok_or_else(|| format!("signing key not found for {}", sid))?;
            signing_keys.push(key);
        }
        let message = Message::try_new(program_id, account_ids, nonces, instruction)
            .map_err(|e| format!("message: {:?}", e))?;
        let witness_set = WitnessSet::for_message(&message, &signing_keys);
        let tx = PublicTransaction::new(message, witness_set);
        wallet.sequencer_client.send_tx_public(tx).await
            .map_err(|e| format!("submit: {}", e))
            .map(|r| r.tx_hash.to_string())
    })?;

    Ok(json!({"success": true, "tx_hash": tx_hash}).to_string())
}

#[no_mangle]
pub extern "C" fn multisig_program_free_string(s: *mut c_char) {
    if !s.is_null() { unsafe { drop(CString::from_raw(s)) }; }
}

#[no_mangle]
pub extern "C" fn multisig_program_version() -> *mut c_char {
    to_cstring("0.1.0".to_string())
}

/// Compute PDA for `multisig_state` account.
/// Seeds: [arg(create_key)]
pub fn compute_multisig_state_pda(program_id: &ProgramId, create_key: &[u8; 32]) -> AccountId {
    let seed_bytes: [u8; 32] = *create_key;
    let pda_seed = nssa_core::program::PdaSeed::new(seed_bytes);
    AccountId::from((program_id, &pda_seed))
}

/// Compute PDA for `proposal` account.
/// Seeds: [const("multisig_prop___"), arg(create_key), arg(proposal_index)]
pub fn compute_proposal_pda(program_id: &ProgramId, create_key: &[u8; 32], proposal_index: u64) -> AccountId {
    use sha2::{Sha256, Digest};
    let mut hasher = Sha256::new();
    {
        let mut padded = [0u8; 32];
        let src = b"multisig_prop___";
        padded[..src.len()].copy_from_slice(src);
        hasher.update(&padded);
    }
    hasher.update(create_key as &[u8]);
    hasher.update(&proposal_index.to_le_bytes());
    let combined: [u8; 32] = hasher.finalize().into();
    let pda_seed = nssa_core::program::PdaSeed::new(combined);
    AccountId::from((program_id, &pda_seed))
}
